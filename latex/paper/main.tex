%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University Assignment Title Page 
% LaTeX Template
% Version 1.0 (27/12/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% WikiBooks (http://en.wikibooks.org/wiki/LaTeX/Title_Creation)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% 
% Instructions for using this template:
% This title page is capable of being compiled as is. This is not useful for 
% including it in another document. To do this, you have two options: 
%
% 1) Copy/paste everything between \begin{document} and \end{document} 
% starting at \begin{titlepage} and paste this into another LaTeX file where you 
% want your title page.
% OR
% 2) Remove everything outside the \begin{titlepage} and \end{titlepage} and 
% move this file to the same directory as the LaTeX file you wish to add it to. 
% Then add \input{./title_page_1.tex} to your LaTeX file where you want your
% title page.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\title{Title page with logo}
%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[11pt]{article}
\usepackage[italian]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{filecontents}
\usepackage{verbatim}
\usepackage{eurosym}
\usepackage[export]{adjustbox}

\usepackage[margin=3cm]{geometry}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    aboveskip=15pt, % Adjust the space above the listing
    belowskip=15pt, % Adjust the space below the listing
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}
\begin{titlepage}

    \newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

    \center % Center everything on the page

    %----------------------------------------------------------------------------------------
    %	HEADING SECTIONS
    %----------------------------------------------------------------------------------------

    \textsc{\LARGE Universit√† di Messina}\\[1.5cm] % Name of your university/college
    \textsc{\Large Dipartimento di scienze matematiche e informatiche, scienze fisiche e della terra}\\[0.5cm] % Major heading such as course name
    \textsc{\large Corso di Laurea Triennale in Informatica}\\[0.5cm] % Minor heading such as course title

    %----------------------------------------------------------------------------------------
    %	TITLE SECTION
    %----------------------------------------------------------------------------------------

    \HRule \\[0.4cm]
    { \huge \bfseries Distributed computation of linear algebra operations}\\[0.4cm] % Title of your document
    \HRule \\[1.5cm]

    %----------------------------------------------------------------------------------------
    %	AUTHOR SECTION
    %----------------------------------------------------------------------------------------

    \begin{minipage}{0.4\textwidth}
        \begin{flushleft} \large
            \emph{Author:}\\
            Gabriele \textsc{Aloisio} \textit{(503264)} \\
        \end{flushleft}
    \end{minipage}
    ~
    \begin{minipage}{0.4\textwidth}
        \begin{flushright} \large
            \emph{Supervisor:} \\
            prof. Roberto \textsc{Marino} \\
        \end{flushright}
    \end{minipage}\\[2cm]

    % If you don't want a supervisor, uncomment the two lines below and remove the section above
    %\Large \emph{Author:}\\
    %John \textsc{Smith}\\[3cm] % Your name

    %----------------------------------------------------------------------------------------
    %	DATE SECTION
    %----------------------------------------------------------------------------------------

    {\large \today}\\[2cm] % Date, change the \today to a set date if you want to be precise

    %----------------------------------------------------------------------------------------
    %	LOGO SECTION
    %----------------------------------------------------------------------------------------

    \includegraphics[width=70px, keepaspectratio]{unime.png}\\[1cm] % Include a department/university logo - this will require the graphicx package

    %----------------------------------------------------------------------------------------

    \vfill % Fill the rest of the page with whitespace

\end{titlepage}

\tableofcontents
\pagebreak

\section{Abstract}

\section{Introduction}
Matrix operations are fundamental in numerous scientific and computational domains, serving as the building blocks for various applications. However, traditional sequential computation on a single machine often becomes a bottleneck, limiting the speed and scalability of matrix calculations. To address this problem, we are going to use an open-source distributed computing framework called \textbf{Ray}.

\subsection{Overview of distributed systems and networks}
A distributed system consists of multiple interconnected computers that collaborate and coordinate their activities to achieve a common goal. These systems are designed to tackle tasks that cannot be efficiently computed by a single machine. Networks serve as the backbone of distributed systems, enabling communication among the connected nodes. Network infrastructures enable coordination, data sharing, and synchronization across distributed systems, regardless of their physical locations.

\subsection{The Ray library}
The Ray library is an open-source distributed computing framework primarily designed for building scalable and high-performance applications. It was developed by the company Anyscale, which aimed to simplify the development of distributed and parallel computing applications. When it comes to matrix operation computation, using Ray for distributed computation offers several advantages over performing the operations on a single machine:
\begin{itemize}
    \item \textbf{Faster execution}: With Ray you can use multiple machines and CPUs to compute operations. This significantly reduces the computation time compared to a single machine. Each machine can work on a subset of the matrix data, completing the calculations in parallel. This distributed approach can lead to substantial speedups.
    \item \textbf{Scalability}: As the size of the matrices grows, a single machine may struggle to handle the computational demands due to memory limitations or processing power constraints. Ray allows you to scale horizontally by adding more machines to the distributed setup.
    \item \textbf{Fault tolerance}: Ray offers fault tolerance mechanisms that ensure the continuity of computation even in the presence of failures. If a machine participating in the distributed computation fails, Ray can automatically redistribute the workload to other available machines.
    \item \textbf{Resource utilization}: With Ray, each machine contributes its processing power and memory capacity to the overall computation. This efficient utilization of resources allows you to make the most of the available hardware infrastructure, compared to a single machine that may be underutilized.
\end{itemize}


\pagebreak
\section{Case study}

\section{Implementation}
\subsection{Python}
Python is a versatile and high-level programming language known for its simplicity and readability. It is widely used for a variety of applications, including web development, data analysis, artificial intelligence, scientific computing, and automation. It supports multiple programming paradigms, including procedural, object-oriented, and functional programming, and its large and active community contributes to a vast ecosystem of libraries and frameworks, making it a powerful tool for a wide range of tasks. It is one of the two languages supported by Ray, alongside Java.

\subsection{Ray}
To parallelize a function with Ray, import Ray and and initialize it with \textit{ray.init()}. Then decorate the function with \textit{@ray.remote} to declare that you want to run this function remotely. Lastly, call the function with \textit{.remote()} instead of calling it normally. This remote call yields a future, a Ray object reference, that you can then fetch with \textit{ray.get}:

\begin{lstlisting}[language=Python]
import ray
ray.init()

@ray.remote
def f(x):
    return x * x

futures = [f.remote(i) for i in range(4)]
print(ray.get(futures)) # [0, 1, 4, 9]
    \end{lstlisting}

\subsubsection{Ray clusters}
To run Ray applications on multiple nodes you must first deploy a \textbf{Ray cluster}. A Ray cluster is a set of worker nodes connected to a common Ray head node. These nodes can be physical machines, virtual machines, or containers running on a cloud infrastructure or a cluster manager like Kubernetes. Ray clusters can be fixed-size, or they may autoscale up and down according to the resources requested by applications running on the cluster.
\\\\
Each Ray cluster typically has one special node called the \textbf{head node}. This is where the main driver program is executed, which manages the cluster, schedules tasks, and communicates with the other nodes. The head node also hosts the Ray Dashboard, a web-based interface for monitoring and managing the cluster.
\\\\
The other nodes in the cluster are known as \textbf{workers}. These nodes are responsible for executing tasks and running jobs. Workers can be distributed across multiple machines and are managed by the head node. They execute user-defined Python functions and can be scaled up or down dynamically based on demand.
\\\\
A ray cluster is set up using a \textit{yaml} file, where all the details about the cluster configuration are defined. Once the file is ready, we simply launch \textit{ray up cluster.yaml} to start a ray instance on all worker nodes over ssh.
\begin{lstlisting}[caption={cluster.yaml}]
cluster_name: distmat

provider:
    type: local
    head_ip: "192.168.128.129"
    worker_ips:
    [
        "192.168.128.210",
        "192.168.128.211",
        "192.168.128.212",
        "192.168.128.213",
        "192.168.128.214",
        "192.168.128.220",
        "192.168.128.221",
        "192.168.128.222",
        "192.168.128.223",
        "192.168.128.224",
    ]

auth:
    ssh_user: <user>

upscaling_speed: 1.0
idle_timeout_minutes: 5
head_start_ray_commands:
    - ray stop
    - ulimit -c unlimited && ray start --head --port=6379 --autoscaling-config=~/ray_bootstrap_config.yaml
worker_start_ray_commands:
    - ray stop
    - ray start --address=$RAY_HEAD_IP:6379

\end{lstlisting}

\subsubsection{Cluster architecture}

\pagebreak
\subsection{The Matrix class}
Before implementing the parallelized algorithms for Ray, we write the code for the serial execution in the \textbf{Matrix} class (most of the functions defined in the class are auxiliary therefore were excluded for practical purposes):

\begin{lstlisting}[language=Python, label=Matrix class]
class Matrix:
    def __init__(self, data):
        if isinstance(data, list):
            self.data = [[round(val, 8) for val in row]
                                        for row in data]
        else:
            raise ValueError("Input must be a list")
    
    [...]

    def dot(A, B): [...]
    def det(self): [...]
    def rank(self): [...]
    def inv(self): [...]
\end{lstlisting}
Which we modify later to achieve parallelization with Ray.

\pagebreak
\subsubsection{Dot product}
\textbf{Matrix multiplication} is a binary operation that produces a matrix from two matrices. For matrix multiplication, the number of columns in the first matrix must be equal to the number of rows in the second matrix. The resulting matrix, known as the matrix \textbf{product}, has the number of rows of the first and the number of columns of the second matrix.
$$
    A = \begin{bmatrix}
        a_{11} & a_{12} & \dots  & a_{1n} \\
        a_{21} & a_{22} & \dots  & a_{2n} \\
        \vdots & \vdots & \ddots & \vdots \\
        a_{m1} & a_{m2} & \dots  & a_{mn}
    \end{bmatrix}, \quad
    B = \begin{bmatrix}
        b_{11} & b_{12} & \dots  & b_{1p} \\
        b_{21} & b_{22} & \dots  & b_{2p} \\
        \vdots & \vdots & \ddots & \vdots \\
        b_{n1} & b_{n2} & \dots  & b_{np}
    \end{bmatrix}
$$
The matrix multiplication of $A$ and $B$ is denoted as $C = A \cdot B$. The resulting matrix $C$ will have dimensions $m \times p$. The entry $c_{ij}$ of the resulting matrix $C$ is computed as follows:
$$
    c_{ij} = a_{i1} \cdot b_{1j} + a_{i2} \cdot b_{2j} + \dots + a_{in} \cdot b_{nj} = \sum_{k=1}^{n} a_{ik} \cdot b_{kj}
$$
The resulting matrix $C$ can be expressed as:
$$
    C = \begin{bmatrix}
        c_{11} & c_{12} & \dots  & c_{1p} \\
        c_{21} & c_{22} & \dots  & c_{2p} \\
        \vdots & \vdots & \ddots & \vdots \\
        c_{m1} & c_{m2} & \dots  & c_{mp}
    \end{bmatrix}
$$
\\
The definition above can be described as the following code:
\begin{lstlisting}[language=Python, caption={Dot function}]
@staticmethod
def dot(A, B):
    if A.is_matrix() and B.is_matrix():
        a_rows, a_cols = A.shape()
        b_rows, b_cols = B.shape()

        if a_cols == b_rows:
            result = [[0] * b_cols for _ in range(A.shape()[0])]
            for i in range(A.shape()[0]):
                for j in range(b_cols):
                    for k in range(a_cols):
                        result[i][j] += A.data[i][k] * B.data[k][j]
            return Matrix(result)
        else:
            raise ValueError(
                "Matrix dimensions do not match for dot product")
    else:
        raise ValueError("Dot product requires a Matrix object")
\end{lstlisting}
\vfill
To parallelize this function, we simply delegate the calculation made in line 12 to an auxiliary function \textit{dot\_calc} defined in the \textit{tasks.py} file:
\begin{lstlisting}[language=Python, caption={dot\_calc}]
@ray.remote
def dot_calc(A, B, i, j, k):
    return A.data[i][k] * B.data[k][j]
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Parallelized dot function}]
@staticmethod
def dot(A, B):
    if A.is_matrix() and B.is_matrix():
        a_rows, a_cols = A.shape()
        b_rows, b_cols = B.shape()

        if a_cols == b_rows:
            result = [[0] * b_cols for _ in range(a_rows)]
            futures = []

            for i in range(a_rows):
                for j in range(b_cols):
                    for k in range(a_cols):
                        # result[i][j] += A.data[i][k] * B.data[k][j]
                        futures.append(((i, j), t.dot_calc.remote(A, B, i, j, k)))
            
            for future in futures:
                i, j = future[0]
                result[i][j] += ray.get(future[1])

            return Matrix(result)
        else:
            raise ValueError(
                "Matrix dimensions do not match for dot product")
    else:
        raise ValueError("Dot product requires a Matrix object")
\end{lstlisting}

\pagebreak
\subsubsection{Determinant}
The \textbf{determinant} is a scalar value that is a function of the entries of a square matrix. It characterizes some properties of the matrix and the linear map represented by the matrix. In particular, the determinant is nonzero if and only if the matrix is \textbf{invertible}.
\\\\
To compute the determinant of matrices with order greater than 2 we are going to use the \textbf{Laplace method}. Let $A$ be a square matrix of size $n \times n$. The Laplace expansion of the determinant along the $i$th row is given by:

$$
    \det(A) = a_{i1} C_{i1} + a_{i2} C_{i2} + \ldots + a_{in} C_{in}
$$
where $C_{ij}$ denotes the cofactor of the element $a_{ij}$. The \textbf{cofactor} $C_{ij}$ is calculated as follows:

$$
    C_{ij} = (-1)^{i+j} \cdot \det(M_{ij})
$$
where $\det(M_{ij})$ represents the determinant of the submatrix obtained by deleting the $i$th row and $j$th column from matrix $A$.
\\\\
Using the Laplace method, the determinant can be calculated recursively by expanding along any row or column until a $2 \times 2$ matrix is reached, for which the determinant can be directly computed. It provides an alternative approach for determining the determinant of a matrix and can be particularly useful for matrices of larger sizes. It's an essential operation since it's used in the other operations of this study.
\\\\
The Laplace method can be transposed to code in the following way:
\begin{lstlisting}[language=Python, caption={Determinant function}]
def det(self):
    if self.is_square():
        data = self.get()
        _, cols = self.shape()

        if cols == 1:
            return data[0][0]

        elif cols == 2:
            return (data[0][0] * data[1][1]) - (data[0][1] * data[1][0])

        else:
            det_value = 0

            for j in range(cols):
                minor = self.minor(0, j)
                det_value += ((-1) ** j) * data[0][j] * minor.det()

            return det_value

    else:
        raise ValueError("Cannot compute determinant of a non-square matrix")
\end{lstlisting}
The function is then parallelized by defining a variant of the \textit{minor} function, \textit{dist\_minor}, which distributes the workload of computing all minors of the matrix.

\begin{lstlisting}[language=Python, caption={dist\_minor}]
@ray.remote
def dist_minor(A, i, j):
    '''
    Extract a minor matrix by removing the ith row and jth column
    '''

    data = A.get()
    minor_data = [row[:j] + row[j + 1:]
                  for row_idx, row in enumerate(data) if row_idx != i]

    return Matrix(minor_data)
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Parallelized determinant function}]
def det(self):
if self.is_square():
    data = self.get()
    _, cols = self.shape()

    if cols == 1:
        return data[0][0]

    elif cols == 2:
        return (data[0][0] * data[1][1]) - (data[0][1] * data[1][0])

    else:
        det_value = 0
        minors_futures = 
            [Matrix.dist_minor.remote(self, 0, j) for j in range(cols)]
        
            minors = ray.get(minors_futures)

        for minor, j in zip(minors, range(cols)):
            # minor = self.minor(0, j)
            det_value += ((-1) ** j) * data[0][j] * minor.det()

        return det_value

else:
    raise ValueError(
        "Cannot compute determinant of a non-square matrix")
\end{lstlisting}


\pagebreak
\subsubsection{Rank}
The \textbf{rank} of a matrix $A$, denoted as $\text{rank}(A)$, is defined as the maximum number of linearly independent rows or columns in the matrix. We chose to determine the rank of a matrix by using the minor criterion, also known as the \textbf{criterion of minors}. According to this criterion, the rank of a matrix is equal to the largest order of a non-zero determinant of any square submatrix within the given matrix.
\\
\\
Let $A$ be a matrix of size $m \times n$, and let $j$ be the order of the largest non-zero determinant among all square submatrices of $A$. Then the rank of $A$, denoted as $\text{rank}(A)$, is equal to $j$.

\begin{itemize}
    \item{To apply the minor criterion, we calculate the determinants of all possible square submatrices of $A$, ranging from $1 \times 1$ to $\min(m,n) \times \min(m,n)$. The order of the largest non-zero determinant among these submatrices gives us the rank of $A$.}
    \item{If there is a non-zero determinant of order $j$, but all determinants of order $k+1$ or higher are zero, then the rank of $A$ is $j$.}
\end{itemize}
This is then brought to code as the following:

\begin{lstlisting}[language=Python, caption={Rank function}]
def rank(self):
    rows, cols = self.shape()
    j1 = min(rows, cols)

    for i in range(j1, 1, -1):
        if self.get_square_submatrices(i) != -1:
            return i    
\end{lstlisting}
The function \textit{get\_square\_submatrices(i)} is an auxiliary function used to calculate all the possible square submatrices of a matrix of order $i$:
\begin{lstlisting}[language=Python, caption={get\_square\_submatrices}]
def get_square_submatrices(self, order):
    data = self.get()
    rows, cols = self.shape()
    submatrices = []

    for start_row in range(rows - order + 1):
        for start_col in range(cols - order + 1):
            submatrix = []

            for row in range(order):
                submatrix.append(
                    data[start_row + row][start_col:start_col + order])

            submatrices.append(Matrix(submatrix))

    return submatrices
\end{lstlisting}
This is then parallelized by distributing the computation of \textit{get\_square\_submatrices},  creating a further \textbf{remote} auxiliary function, \textit{get\_submatrix\_task}:
\begin{lstlisting}[language=Python, caption={get\_square\_submatrices}]
def get_square_submatrices(self, order):
    data = self.get()
    rows, cols = self.shape()
    futures = []

    for start_row in range(rows - order + 1):
        for start_col in range(cols - order + 1):            
            futures.append(t.get_submatrix_task.remote(start_row, start_col, order, data))

    return ray.get(futures)
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={get\_submatrix\_task}]
@ray.remote
def get_submatrix_task(start_row, start_col, order, data):
        from matrix import Matrix
        submatrix = []

        for row in range(order):
            submatrix.append(
                data[start_row + row][start_col:start_col + order])
            
        return submatrix
\end{lstlisting}

\pagebreak
\subsubsection{Inverse}
The \textbf{inverse of a matrix} is a fundamental concept in linear algebra. For a square matrix $A$, if an inverse exists, it is denoted as $A^{-1}$. A matrix is invertible (or non-singular) if and only if its determinant is non-zero. The concept of the inverse of a matrix is closely related to solving linear systems of equations. Consider a system of linear equations represented in matrix form as $Ax = b$: 
$$
\begin{array}{@{}cccc@{}}
    A & x &  & b \\
    \begin{bmatrix}
        a_{11} & a_{12} & \cdots & a_{1n} \\
        a_{21} & a_{22} & \cdots & a_{2n} \\
        \vdots & \vdots & \ddots & \vdots \\
        a_{m1} & a_{m2} & \cdots & a_{mn}
    \end{bmatrix}
    &
    \begin{bmatrix}
        x_1 \\
        x_2 \\
        \vdots \\
        x_n
    \end{bmatrix}
    & = &
    \begin{bmatrix}
        b_1 \\
        b_2 \\
        \vdots \\
        b_m
    \end{bmatrix}
\end{array}
$$
where:
\begin{itemize}
    \item{$A$ is the coefficient matrix}
    \item{$x$ is the vector of variables we want to solve for}
    \item{$b$ is the vector of constants on the right-hand side}
\end{itemize}
The \textbf{solution} for $x$ can be found using the inverse of $A$, hence $x = A^{-1}b$. To find the inverse of a matrix, one common method is to use the formula:
$$
    A^{-1} = \frac{1}{\det(A)} \cdot \text{adj}(A)
$$
where $\det(A)$ denotes the determinant of matrix $A$ and $\text{adj}(A)$ represents the \textbf{adjugate} of matrix $A$. The adjugate of matrix $A$ is obtained by taking the transpose of the \textbf{matrix of cofactors} of $A$. The cofactor $C_{ij}$ is calculated as:
$$
    C_{ij} = (-1)^{i+j} \cdot \det(M_{ij})
$$
where $\det(M_{ij})$ represents the determinant of the submatrix obtained by deleting the $i$th row and $j$th column from matrix $A$. The inverse of matrix $A$ satisfies the following condition:
$$
    A \cdot A^{-1} = A^{-1} \cdot A = I
$$



\section{Result of tests}


\section{Conclusion}

\end{document}